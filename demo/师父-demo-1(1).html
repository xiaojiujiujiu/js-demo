<!DOCTYPE html>
<html>
<head>
	<title>博学谷-js基础</title>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	<meta name="description" content="" />
	<meta name="author" content="pc" />
	<meta name="format-detection" content="telephone=no" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<style>
		.cls,.show{
			width: 100px;
			height: 100px;
			background-color: #09c;
		}
		.show{ display: block;  }
		.hide{ display: hide; }
	</style>
</head>
<body>
	<!-- <button id="btn" >隐藏</button>
	<div id="box" class="cls"></div> -->
	
	<!-- <div class="cls" id="box"></div> -->

	<div>div</div>
	<p>pp</p>
	<h6>h6</h6>
	<h6>h6</h6>
	<span>span</span>
	<div>div</div>
	<p>pp</p>	
	<h6>h6</h6>
	<h6>h6</h6>
	<span>span</span>
	<div>div</div>
	<p>pp</p>


	<script>





		/* js dom */
		//追加类名
		// var btn =document.getElementById("btn");
		// var box = document.getElementById("box");
		// btn.onclick = function(){
		// 	if(btn.innerText=='隐藏'){
		// 		box.className = 'hide';
		// 		btn.innerText='显示';
		// 	}else{
		// 		box.className = 'show';
		// 		btn.innerText='隐藏';
		// 	}
			
		// }


		// js 的的undefined 类型
		//var num; //没有给值 该变量就说undefined ;
		// null  用来清除变量

		//js 中的 布尔类型
		// var  b=false,b1=null,b3=0,b4='';b5=undefined;

		// var a=1;
		// var c=1;
		// console.log(a++); //先参与运算 后进行 自+  也就说先 打印 a的值 然后进行 ++
		// console.log(++c); //先自加 之后在参与运算 也就说 先让c +1 然后在 输出c 的值

		//var a=1;var b = ++a + ++a;console.log(b);//
		//              2 + 3   b=5

		//var a=1; var b= a++ +  ++a ; console.log(b);
		//              1    + 3       b= 4;

		//var a=1; var b=a++ + a++ ; console.log(b);
		//			   1 + 2     b =3;

		//var a=1;var b= ++a + a++ ;console.log(b);
		//				2 + 2 	b=4

		// &&  运算   只要有一个味 false 就返回 false

		// || 运算。只要有一个味 true  就会返回 true	

		//短路运算 返回 对表达式结果 起决定性作用的值
		//console.log('1' && '我是返回值');



		//js 中检测数据类型  typeof  返回的是个字符串
		// console.log(typeof 222); //number
		// console.log(typeof '322');  //string
		// console.log(typeof true);  // boolean
		// console.log(typeof  null);  // object 
		// console.log(typeof  undefined);  //undefined


		// var  a=10;
		// ++a;     // 11
		// var c=++a +2;  // 12 + 2  14
		// console.log(c);

		// var b=10;
		// b++;   // 11
		// var c=b++ +2; // 11 +2  13
		// console.log(c)

		// //a = 7  b =15  c= 10   d = 8 + 15 * 2 - 12  d = 26
		// var a= 1+2 * 3;
		// var b=2* 4+5 -4 +12 /2 ;
		// var c= 2*(4+5) -(4+12) /2 ;
		// var d=++a +b *2 -(c+2);


		// 逻辑操作符 返回的是 布尔值
		//console.log(1 && 2);//  2

		// 逻辑操作符 优先级。 ! >  && > ||	

		//var a=3 > 5 && 2 <7  && 3  ==4;
		//a = false && true && false ;——》 a=false;
		//console.log(a);

		//var  b=3 <=4 || 3 > 1  || 3 != 2; //b= true;
		//console.log(b);

		//var c= 2=== "2";
		//console.log(c) ;//false

		//var d= !c || b && a;
		//console.log(d); // true || false  d =true;

		// var num =10;
		// num +=2; //每次 自加2    相当于 num =num+2;

		// var re=5;
		//re *=5; //25

		//var a=10,b=20,c=30;// 用 ， 来声明 多个变量


		/*js 继承*/

		// function A(){ //定义构造函数
		// 	this.abc=12;
		// }

		// A.prototype.show =function(){ //定义原型方法 打印该 函数的属性
		// 	console.log(this.abc);
		// }

		// B.prototype =A.prototype;// 让B的原型 等于 A 的原型
		// //如果再

		// function B(){ //定义B构造函数
		// 	A.call(this);// 吧当前的this指向进行修改
		// }
		// B.prototype.cons = function(){// 定义b 的原型方法
		// 	console.log(333);
		// }

		// var b=new B();
		// b.show();
		// b.cons();

		//继承用到的父类
		// function Animal(name,age){
		// 	//属性
		// 	this.name =name || 'Animal';
		// 	this.age= age || 10;
		// 	//实例 方法
		// 	this.sleep =function (){
		// 		console.log(this.name +'睡觉了');
		// 	}
		// }

		// //原型方法
		// Animal.prototype.eat =function(food){
		// 	console.log(this.name+'在吃'+food);
		// };

		// Animal.prototype.motion =function(amt){
		// 	console.log(this.name +'正在'+amt);
		// }

		// /****************原型链 继承***************/
		// // PS 将父类的实例 做为 子类的原型
		// function Cat(){

		// }

		// // 在new 之前 会调用不到 
		// // Cat.prototype.showName = function(){
		// // 	console.log(this.name);
		// // }

		// Cat.prototype =new Animal();
		// //在new 之后增加 自加点 原型方法
		// Cat.prototype.showName = function(){
		// 	console.log('当前的动物名称是'+this.name);
		// }

		// Cat.prototype.name='cat';
		// Cat.prototype.age=20;


		// var cat = new Cat();
		// console.log(cat.name);
		// console.log(cat.name+'今年'+cat.age+'岁');
		// cat.eat('骨头');
		// cat.sleep();
		// cat.showName();
		// cat.motion('跑步');
		// console.log(cat instanceof Animal);//cat 是 Animall的实例。返回true
		// console.log(cat instanceof Cat); //cat 也是Cat 的实例

		// var dog  =new Cat();
		// dog.eat('肉');


		/*优缺点*/
		// 纯粹的继承关系 实例是子类的实例，也是父类的实例
		// 父类新增原型方法 /原型属性，子类 都能够 访问；
		// 简单 易于实现

		// 如果要新增原型方法和属性，必须要在 new Animal这句话执行之后，不能放到构造器中
		// 可以在Cat 构造函数中， 为Cat实例增加实例属性
		// 无法实现多个继承
		// 创建子类实例时。无法向父类构造函数传递参数 
		// 来自原型对象的引用属性 是所有实例 共享的	


		// for循环打印出 99 乘法表
		// for (var i = 1; i <=9; i++) {
		// 	for(var j=1;j<=i;j++){
		// 		document.write(j+' *  '+ i +'  =  ' + j* i +' &nbsp;');
		// 	}
		// 	document.write('<br />')
		// }

		//定义学生对象 有姓名 性别 分数。说话
		// var sub =new Object();
		// sub.name='哇哈哈';
		// sub.sex='男';
		// sub.num=80;
		// sub.say = function(){
		// 	console.log(sub.name+'说话了');
		// }

		// console.log(sub.name);
		// sub.say();

		// 工厂模式 创建函数 
		// function  createSub(name,sex,num,fn){
		// 	var sub =new Object();
		// 	sub.name=name;
		// 	sub.sex=sex;
		// 	sub.num=num;
		// 	sub.fn=fn;
		// 	return sub;
		// };

		// var sub1=createSub('哇哈哈','男',30,function(){
		// 	console.log(333);
		// })

		// var sub2=createSub('王老吉','女',90,function(){
		// 	console.log('去火首选');
		// })

		// console.log(sub1);
		// console.log(sub2);



		//js this指向
		//1 全局中 指向 window
		//console.log(this);  // window 对象

		// // 2 构造函数中
		// function Afun(name){
		// 	this.name =name;
		// 	console.log(this);
		// }
		// var fun = new Afun('aaa');

		// //this 指向 只有在函数 执行 的时候才知道  this 指向的是谁;this 最终指向的是调用他的对象 
		// function a(){
		// 	var user='aaaa';
		// 	console.log(this.user);
		// 	console.log(this);
		// }
		// //var user='bbbbb';
		// //a();


		// var btn=document.getElementById('btn');
		// btn.onclick= function(){
		// 	a();
		// }


		// var  a_funu ={
		// 	user:'this is fun',
		// 	fn:function(){
		// 		console.log(this.user);
		// 	}
		// }

		// //a_funu.fn();//这里 a_fun 调用了 fn 函数  fn中的this 指向调用他的对象 也就说 a_fun 
		// //这句话 还可以看作是 window.a_fun.fu();

		// window.a_funu.fn();

		//var btn = document.getElementById('btn');

		//btn.onclick = function(){
		// 	var _that=this; //把当前的this 存到变量中
		// 	function fn(){
		// 		console.log(_that);//此时的 this  还说指向的windo
		// 	}
		// 	fn();
		// }

		// btn.onclick = function(){
		// 	function fn(){
		// 		console.log(this);
		// 	}
		// 	fn.call(this);//call 作用 改变 this 指向 ；第一个传递的是一个对象，就是要借用的哪个对象
		// }

		// btn.onclick = function(){
		// 	var fn= function (){
		// 		console.log(this);
		// 	}.call(this);
		// }

		

		/*call  apply bind 的差别	*/




		// var o={
		// 	a:10,
		// 	b:{
		// 		a:12,
		// 		fn:function(){
		// 			console.log(this.a);
		// 			console.log(this);
		// 		}
		// 	}
		// }
		// //o.b.fn();

		// var n=o.b.fn;
		// n();

		//如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。


		// function Fun(){
		// 	this.name='aaaa';
		// 	return Object;
		// }
		// var f=new Fun();
		// console.log(f.name);

		// "use strict"
		// console.log(this);



		//冒泡排序
		//var n=0;
		//var arr=[21,53,54,64,645,6,57,22,203,23,44,42,2,424];
		// for(var i=0;i<arr.length-1;i++){
		// 	for(var j=0;j<arr.length-1;j++){
		// 		if(arr[j] > arr[j+1]){
		// 			var newnum=arr[j];
		// 			arr[j]=arr[j+1];
		// 			arr[j+1]=newnum;
		// 		}
		// 		n++;
		// 	}

		// }

		// var arr=[1,2,3,4,5];
		// for(var i=0;i<arr.length-1;i++){
		// 	var flag=true;
		// 	for(var j=0;j<arr.length-1 -i;j++){
		// 		if(arr[j] > arr[j+1]){
		// 			flag=false;
		// 			var newnum=arr[j];
		// 			arr[j]=arr[j+1];
		// 			arr[j+1]=newnum;
		// 		}
		// 		n++;
		// 	}
		// 	if(flag){
		// 		break;
		// 	}
		// }
		// console.log(n);
		// console.log(arr);



		//函数
		//函数 参数 方便 多次调用

		// function fun(num1,num2){//形参 占位符
		// 	console.log(num1+num2);
		// }

		// fun(2,3);

		/*方法作用：求x 到y 蒸熟的和*/
		// function fun(x,y){
		// 	var sum=0;
		// 	for(var i=x;i<=y;i++){
		// 		sum+=i;
		// 	}
		// 	console.log(sum);
		// }
		// fun(1,3);

		//全局变量
		// 在最外层生命的变量 就是全局变量 ，在那里都能够使用
		// var a='aaa';
		// function fun1(){
		// 	console.log(a);//在外层生声明 的变量 在函数内部也能够 使用
		// }

		// fun1();

		// function fun2(){
		// 	var b='bbbb';//在函数内部声明的变量 只能在函数内部使用 在外部调用不到
		// 	c='ccc';//没有 使用var 隐式 声明的全局变量

		// 	console.log(b);
		// 	console.log(c);
		// }

		// fun2();
		// console.log(c);

		// var fun = function(){
		// 	console.log(33);
		// }

		// console.log(typeof fun);//返回数据类型 函数也是一种数据
		// console.log(typeof fun());//

		// // 被当作参数传递的函数 就叫做回调函数
		// var fun1 = function(f){
		// 	console.log('fn');
		// 	f();
		// }

		// fun1(fun);



		/*对象*/
		// var hear = new Object();//声明一个对象

		// hear.name='aaa';//属性。name
		// hear.age = 88;//属性 年龄
		// hear.move = function(){
		// 	console.log(hear.name +'在走');
		// }

		// console.log(hear.move())

		// //对象字面量
		// var stu={
		// 	name:'aa',
		// 	age:30,
		// 	sayHi:function(){
		// 		console.log('aaa');
		// 	}
		// };

		// for(var k in stu){
		// 	console.log(stu[k]);
		// }


		/*js 中的 值类型 和引用类型*/
		//var num =10;
		// function fun(num){
		// 	num =30;
		// 	console.log(num);
		// }
		// fun(num);
		// console.log(num);

		// function Fun(a){
		// 	this.a=a,
		// 	this.sayA =function(){
		// 		console.log(this.a);
		// 	} 
		// }
		// var f = new Fun('aaa');
		// f.sayA();

		// var f2=f;
		// f2.a='bbb';
		// f2.sayA();
		// f.sayA();

		/* 数组的操作 */

		//var arr=[24,423,543,65,2,23];
		//增加
		//arr.push(2);//增加以个元素， 在数组最后追加
		//arr.push(11,22,33,44);//在数组之后 追加n 个元素  并返回 新数组的长度

		//arr.pop();//删除 数组 最后一位
		//arr.reverse();//对数组 进行 翻转
		//console.log(arr.toString());//数组转换成字符串
		//console.log(arr.join()); //数组转换成以 ， 分割的字符串
		//console.log(arr.join('|'));// 以 | 分割
		//arr.shift(); //删除数组的第一个元素
		//arr.unshift('1111');//向 数组前面 添加 元素 可以追加多个
		//var arr2=['11','aa','vv'];
		//console.log(arr2.concat(arr));//把2 个数组合并为一个 数组 并返回合并后的数组
		//console.log(arr);
		//console.log(arr);
		//arr.splice(1,3);//删除 数组下标 1 到3 
		// console.log(arr);

		// var num=[2324,222,131,4242,435345,2242,12312,22];
		// var numA= num.filter(function(e,index,arr){
		// 	if(e >2000){
		// 		return false
		// 	}
		// 	return true;
		// })
		// console.log(num);
		// console.log(numA);


		/* 对象 */
		//字面量 创建对象
		// var o = {};
		// o.name='111';
		// o.age =12;
		// o.sayHello =function(){
		// 	console.log(o.name);
		// }
		// o.sayHello();

		// var o1={};
		// o1['name'] ='111';


		//工厂模式创建对象
		//缺点 不方便 其他方法 或 函数 区分 
		//利用工厂创建对象 本质与字面量创建对象是 一样的
		// 返回的类型 都是object  我们需要有心的创建对象的方法

		// function factoryO(name,age){
		// 	var o={};
		// 	o.name =name;
		// 	o.age =age;
		// 	o.sayHello = function(){
		// 		console.log('我都名字是'+o.name+' 我今年'+o.age+'岁了');
		// 	}
		// 	return o;
		// }

		// var getO = factoryO('哇哈哈',20);
		// getO.sayHello();

		// console.log(Object.prototype.toString.call([]));// 查看对象的类型
		// console.log(Object.prototype.toString.call(''));
		// console.log(Object.prototype.toString.call(2));
		// console.log(Object.prototype.toString.call(true));


		//构造器。使用构造函数来创建对象
		//1 构造函数 和普通函数类似。唯一不同 约定 构造函数的名字 采用 pascal 命名规则【首字母大写】
		//2 调用构造函数 采用 var a = new 构造函数名。之后返回的就是新创见的对象
		//3 在构造函数的内部 使用 this 来表示 刚刚创建的对象 如果需要给对象提供成员。this.xxx=xxx

		//构造函数 
		// 使用构造函数 创建对象 一开始就可以确定 对象的类型
		// function Person(name,age){
		// 	this.name = name;
		// 	this.age =age;
		// 	this.sayHello = function(){
		// 		console.log(this.name);
		// 	}
		// 	// 不需要return 
		// }

		// // 调用构造函数 
		// var a = new Person('aaa',29);
		// //a.sayHello();
		// console.log(a.constructor);

		// var b = new Person('bbb',18);
		// //b.sayHello();
		// console.log(a instanceof Person);

		//es6 创建对象

		// class Person {
		// 	constructor(name,age){
		// 		this.name = name ;
		// 		this.age = age;
		// 	}
		// 	sayHello (){
		// 		console.log(this.name);
		// 	}
		// }
		// var  p = new Person("哇哈哈",18);
		// p.sayHello();

		//只 允许输入数字
		// 如果考虑使用面向对象的方式。完成 该案例 该对象就是文本框
		// 同时也该具备。输入检查 是否输入数字
		// 如果是数字可以。如果是 文本  字母 直接忽略

		//function InputNum(){
		// 	this.inputDom = document.createElement('input');
		// 	this.inputDom.value = '222';
		// 	this.inputDom.onclick = function(){
		// 		var that = this
		// 		console.log(that.value);
		// 	}
		// 	this.appendTo = function(){
		// 		//dom.appendChild(this.inputDom);
		// 		document.body.appendChild(this.inputDom);
		// 	}
		// }

		// var input1 = new InputNum();
		// input1.appendTo();


		//利用对象 设置 元素的样式
		// function css(dom,styleList){
		// 	for(var key in styleList){
		// 		dom.style[key] = styleList[key];
		// 	}
		// }

		// var box = document.getElementById('box');
		// css(box,{
		// 	'width':'100px',
		// 	'height':'100px',
		// 	'border':'1px solid #ccc'
		// });

		//面向对象的 特征
		// 抽象 ：只有在具体的环境中 对象才可以表示具体的事物，在程序中 实际只考虑 对象的目标数据 / 局部性
		// 抽取 局部的信息 只拿我们需要的东西

		//封装 ： 将 具体的操作步骤打包起来 不需要知道内部 是如何处理的，内部是否复杂，只需要知道怎么去使用
		// 比如 电脑 电视机 空调 
		// 函数 -》 简单的封装

		//继承性。
		// 在 OOP 当中表示的就是 扩展 ： 原来已经有一个对象了在其基础上 增加一些东西 成为 新的对象 此时新对象就上继承原来的对象

		//多态：多种状态 也就是说 一个变量 调用 某一个方法 得到不同 的结果 就说多态
		// js 中并没有多大的 作用 js 是弱类型  语言	

		// dom 对象
		// dom 的基本操作。增删查改
		// dom 是：文档对象模型 就是将每一个html标签 当作 节点对象来看待 那么所有的标签就可以看成一个节点数树
        // 增 增加 节点增加 内容 增加属性增加 样式
        // 在html 中所有的内容都是节点 对象，因此   <body>嘻嘻哈哈 哇哈哈</body>  这里的文本标签全部都是对象


        /*******js  的数据类型 *******/
        // 1. 简单类型 值类型。 
        //	string     number   布尔
        // 基本数据类型的变量。存储 数据本身。  基本类型的存储特征
        //var  num = 123;  //在内存中开辟一段空间 这个内存就说num 存储的就是 数字 123
		// 值类型 文件var  文件名 = 文件中存的值
		// 在赋值过程中的区别
		// var num1=1;  var  num2=2;
		//  var =0; function f(n){ n=n+1; }  console.log(n) //为 0  


        // 2. 复杂类型。 符合类型  引用类型
        //   对象。正则。数组。 object 
        // 引用类型 中的数据 个数可能很大  引用类型的变量 只是存储对象的引用[地址]
        // 文件夹 里面有好多文件 文件夹的名称 var  obj = {js 文件 } 快捷方式
        // 2部分。引用的变量。存储的数据
        // 引用类型 在使用的时候 都是。使用变量 来处理 数据。在赋值的时候 就是将一个变量中的数据取出来 拷贝一份
        // 将拷贝的数据 存储到另外一个 变量中 由于引用类型 的变量中存储的事引用而不是数据本身 并没有奖数据进行拷贝 只是拷贝了 数据的地址
        // 内存中还是只有一份 数据
        // function  Funct(){ this.nam'111' }; var  o1= new Funct()  var  o2= new  Funct()
        // 函数内外虽然指向的不同 

        // 3。空类型。 null undefined 
        
        // var o = {num:123}
        // function fn(obj){
        // 	obj.num *=2;
        // 	console.log(obj.num);
        // }

        // fn(o);
        // console.log(o.num);


        // 面向对象：使用对象 帮助做事情  面向对象 基于面向过程  面向过程说根本
        // 凡用 if else 之后需要赋值的 都可以 利用 三元运算符

        /*****************面向对象小结*******************/



        /****************原型 继承**************/
        // 1 原型的基本概念
        // 构造函数 创阿金对象
        // 构造函数的执行本质  对象的动态特性
        // 1 new 创建对象的运算符 该对象 
        //  如果将方法写在函数的内部。 那么函数每次执行 的时候 方法的代码会被解释一次 因此每个对象都包含 一样的 不同的方法【方法是一样的，但
        // 在内存中 指向不同 】 因此 会浪费资源 需要考虑将对象中的方法 复用
        // js 中 只要声明 一个 函数 就会包含 一个对象催在，函数的prototype 属性指向该对象 该对象默认 只包含 一个属性 contructor 在指向回我们的构造函数
        // 神秘对象中的成员 被构造函数 所创建出来的对象所共享 
        // prototype 就是原型的意思 原型原本的含义就是原来的数据，所以在函数背后的神秘对象 就是函数的原型 
        // 由于使用 prototype 这个属性来应用该对象，因此 称作原型 属性
        // 构造函数的原型属性 prototype  简称为 原型
        // 为什么 使用原型：把我们的方法复用性 最大化  提高性能 
        // 函数的 prototype 的对象 就是 该 函数的 原型对象  简称 原型

        /**********原型 构造函数 和 对象之间的关系***********/ 




        // function Person(name,age,gender){
        // 	this.name =name;
        // 	this.age =age;
        // 	this.gender =gender;
        // }

        // Person.prototype.sayHello = function(){
        // 	console.log('你好'+this.name);
        // }

        // var p =new Person('jim',18,'男');
        // p.sayHello();

        /*************原型 继承**************/
        // 所谓的继承 就是扩展【在已有的对象上增加新的功能得到新的】 此时就是继承
        // 对象 p 没有sayHello 方法 ，因为构造函数中就没有
        // 但是p 链接到 原型 中 p.__proto__ = Person.prototype 因此p 就可以调用 sayHello 方法
        // 这个就是 原型 继承 因为p 没有  但是p 继承自原型对象 ，所以p 就有了
        // js 中没有继承的语法 [es6 除外] 凡是涉及到 原来一个对象没有 从另一个对象中 获得到的数据  那么久是继承



        // function Person(name,age){
        // 	this.name=name;
        // 	this.age=age;
        // 	this.sayHello= function(){
        // 		console.log(this.name);
        // 	}
        // }

        // var p=new Person('aa',18);
        // p.sayHello();

        // var  p2= new Person('bb',19);
        // p2.sayHello();

        // console.log(p.sayHello == p2.sayHello);


        /*******原型的 一般  继承 ******/
        // 讲所有的方法都加到 原型 中 使用 对象的 动态 特性来增加 
        // function Person(name,age){
        // 	this.name=name;
        // 	this.age = age;
        // }

        // Person.prototype.sayHello = function(){
        // 	console.log(this.name);
        // }

        // var p1 = new Person('ee',12);
        // p1.sayHello();

        // var p2 = new Person('tt',19);
        // p2.sayHello();

        // console.log(p1.sayHello == p2.sayHello);

        /***********替换原型的方式***************/
        // 构造函数的prototype 指向新的对象

      //   function  Person(){}
      //   Person.prototype = { // 直接替换原型 对象 来实现继承 
    		// sayHello:function(){
    		// 	console.log('aaa');
    		// }
      //   }

      //   var  p = new Person();//p 就带有sayHello 方法
      //   p.sayHello();

        /**********替换原型的方式 注意事项************/
        // 原型继承 替换的 时机 决定了  创建出来的对象 继承于 原始的 还是新的对象
        // 案例1
        // function Person(){}

        // Person.prototype.sayHello = function(){
        // 	console.log('原始的 sayHello')
        // }
        // Person.prototype = {
        // 	sayHello:function(){
        // 		console.log('替换对象的 sayHello');
        // 	},
        // 	runFun:function(){
        // 		console.log('替换的 runfun方法')
        // 	}
        // }
        // var  p = new Person();
        // p.sayHello();
        // p.runFun();

        // 案例2
        // function Person(){}
        // var  p1 = new Person();

        // Person.prototype.sayHello = function(){
        // 	console.log('原始的 sayHello')
        // }
        // var  p2 = new Person();
        // Person.prototype = {
        // 	sayHello:function(){
        // 		console.log('替换对象的 sayHello');
        // 	},
        // 	runFun:function(){
        // 		console.log('替换的 runfun方法')
        // 	}
        // }
        
        // var  p3 = new Person();

        // p1.sayHello();// 原始
        // p2.sayHello();// 原始
        // p3.sayHello();// 替换

        /********* object create 方法***********/
        // 语法
        //Object.create(‘对象’); // 返回值 是对象
        // 该方法的含义 返回一个原型对象为制定参数的的对象 的 对象
 
 		// var o = {
 		// 	sayHello:function(){
 		// 		console.log('say hello')
 		// 	}
 		// }
 		// var o1 =  Object.create(o);
 		// //返回的o1   继承自 o
 		// o1.sayHello();

 		/***************类*****************/
 		// 类class  讲 js 中的构造函数 称为 类 构造函数的 名称 就是 类的 名称
 		// 构造函数 构造器 (constructor)  构造方法 的概念是一样 的
 		// 利用构造函数 创建对象的 过程 称为实例化   将构造函数创建出来的对象又称作为 构造函数的实例
 		// 有些时候 会将 熟悉称为 字段 

 		//静态成员
 		// 凡是定义后 由构造方法 所使用的 成员
 		// 如果需要在 静态方法中使用 实例成员  1 将实例对象 传入方法这个使用
 		// 2 在静态方法中 创建 实例 对象 然后使用 
 		// 无论 是在实例方法中 还是静态方法中， 都可以访问 静态成员（只要保证可以访问到构造函数）
 		// class Person{
 		// 	constructor(name,age){
 		// 		this.name=name;
 		// 		this.age=age;
 		// 	}
 		// 	sayHello(){
 		// 		console.log(this.name);
 		// 	}
 		// }
 		// var  p2 = new Person('111');
 		// p2.sayHello();

 		//实例成员
 		//凡是定义后 由实例对象 所使用的 成员 就是 实例成员
 		// 只允许在实例方法中被访问 ，在静态 方法中不能访问
 		// function Person(){
 		// 	this.name ='jim';
 		// 	this.sayHello = function(){
 		// 		console.log(this.name);
 		// 	}
 		// }

 		// Person.sayGood = function(){
 		// 	console.log(this == Person);
 		// }

 		// Person.sayGood();

 		// //1 将实例对象 传入方法这个使用
 		// Person.method1 = function(obj){
 		// 	console.log(obj.name);
 		// }

 		// var p = new Person();
 		// Person.method1(p);

 		// // 2 在静态方法中 创建 实例 对象 然后使用 
 		// Person.method2 = function(){
 		// 	var o = new Person();
 		// 	console.log(o.name);
 		// }

 		// Person.method2();



 		/************混入*************/
 		// 把水混合到 果汁 得到 个 既有水的特性  又有果汁的特征
 		// 将以个对象的成员 加入到另一个 对象中  就可以完成 对象的扩展【继承】

 		// var  o1 ={name:'111' }
 		// var  o2={ sayHello:function(){console.log(this.name) }}
 		// o2.name = o1.name; //o2 继承自 o1
 		// 将 o1 的name  混入到o2 中
 		// o2.sayHello();

 		//如果对象的成员 比较多的时候 该 如何处理？
 		// 使用min 可以将 一个对象 混入到 另一个对象中
 		// function min(obj1,obj2){
 		// 	for(var k in obj2){
 		// 		obj1[k] = obj2[k]
 		// 	}
 		// }

 		//extebd 扩展
 		// 所谓的混入就是将 对象 加入到另一个对象中 扩展该对象

 		/**********混合式继承**********/
 		// 1原型式继承 

 		// function extend (obj1,obj2){
 		// 	for(var k in obj2){
 		// 		obj1[k] = obj2[k]
 		// 	}
 		// }

 		// Person.fn = Person.prototype;

 		// function Person(options){
 		// 	extend(this,options)
 		// }

 		// Person.prototype.extend = function(obj){
 		// 	extend(this,obj);
 		// }
 		// //继承完成

 		// // 扩展

 		// Person.fn.extend({
 		// 	sayHello:function(){
 		// 		console.log('你好'+(this.name || '哇哈哈'));
 		// 	}
 		// })

 		// var p = new Person({'name':'AD'});
 		// p.sayHello();

 		// var p2 = new Person();
 		// p2.sayHello()


 		/*********函数 length**********/

 		// function foo(){} // 
 		// console.log(foo.length);// 0

 		// function foo1(a,b,c){}
 		// console.log(foo1.length);//3
 		// 用来判断 函数的参数 的个数

 		// arguments  对象
 		// 参数的复数 形式 在调用函数的时候会给函数传入参数 但参数的个数不确定的时候
 		// 所有在调用 的时候传入的参数 都会被arguments 获取到
 		// 简单的说 arguments 存储的就是 参数的集合
 		// js 中 函数的参数 也是动态的
 		// 在 实际调用的时候 就是 实际 调用时 传入的所有 参数 【是个伪数组】
 		// 如何判断 调用时的参数 个数 与 参数定义时 的函数 参数 个数一致
 		// foo.length ==  arguments.length;
 		// 使用 arguments 可以保证在 函数定义 不写 函数参数的情况下 也可以 获得 函数调用时传入的所有参数
 		// 在不确定函数有多少参数 和 需要函数有动态参数的时候 来使用

 		// function foo(a,b,c){
 		// 	console.log(arguments);
 		// }

 		// foo(12,1,3);
 		// function foo(){
 		// 	console.log(arguments)
 		// }

 		// foo(0,1,2,3,3,4);

 		// 使用 arguments 可以保证在 函数定义 不写 函数参数的情况下 也可以 获得 函数调用时传入的所有参数
 		// 在不确定函数有多少参数 和 需要函数有动态参数的时候 来使用

 		// function getMax(a,b){ // 判断2 个数的大小
 		// 	return a> b? a: b;
 		// }

 		//需要判断多个数中较大的数字
 		//需要随意的提供参数
 		// function getMax2(){
 		// 	var args = arguments;// 为了减少代码的拼写错误
 		// 	var maxNum = args[0];
 		// 	for(var i=1;i<args.length;i++){
 		// 		if(maxNum<args[i]){
 		// 			maxNum = args[i]
 		// 		}
 		// 	}
 		// 	return maxNum;
 		// }
 		// console.log(getMax2(22,11,33,44));

 		// 希望函数有动态参数 根据传入不同数目的参数 获取不同的结果
 		// jq 中 css attr html text 
 		// 实现css 方法  1 dom 元素  2 字符串

 		// function css(){
 		// 	var args = arguments;
 		// 	var getStyle='';
 		// 	if(args.length >=3){
 		// 		args[0].style[args[1]] = args[2]
 		// 	}else{
 		// 		getStyle = args[0].style[args[1]];
 		// 	}

 		// 	return getStyle;
 		// }

 		// var box = document.getElementById('box');
 		// css(box,'width','200px');
 		// console.log(css(box,'width'));


 		//将字符串 作为代码来执行
 		// eval  函数：允许将一个字符串 作为 一段JS 来执行
 		//容易造成全局 污染
 		//eval("var  num =122");//此时相当于  在代码中var num =123
 		//console.log(num);

 		//   Function 函数 来 代替eval来进行调用 【执行字符串代码】
 		// 用于生成一个函数  
 		// 使用语法 
 		//new Function('参与1 ','参数与2','方法体');//会返回个函数  创建一个对象

 		// var  fun = new Function('a','b','return a+b');
 		// //得到的函数 等价于
 		// function fun1(a,b){
 		// 	return a+b;
 		// }

 		// console.log(fun(1,3));

 		// 练习
 		// 求2 个数字的积
 		// 求任意个数字的和

 		// var funJ = new Function('a','b','return a*b');
 		// console.log(funJ(3,2));

 		// var funh =new Function('var args =arguments; var num=0;for(var i=0;i<args.length;i++){num=num+args[i]; }; return num;');
 		// console.log(funh(1,5));

 		// 带有格式的字符串拼接
 		// 字符串请求的方式 使用ajax  方式
 		// 使用 模板 字符串 【ES6 的新语法 】轻松的实现 可换行字符串


 		// 函数 于 Function 的关系
 		// 函数 就是 Function 的实例；Functuon 是 函数的 构造函数
 		// 实例对象有一个 继承的 constructor 指向的就是 构造函数
 		// 自己定义的任意函数 可以知道 函数的constructor 就是 Function
 		// 得到的 结论 就是 函数就是 Function 的实例 
 		// function foo(){}
 		// console.log(foo.constructor ==Function);

 		// 函数 Function 与 Function.prototype 的关系
 		// 函数是 Function的 实例；函数的 contructor 指向 Function； Function.prototype 又指向了Function 本身
 		// 大写的 Function 也是函数

 		// 原型继承的关系【原型链】

 		// function Foo(){}

 		// var o=new Foo();
 		// o >  Foo.prototype  > Object.prototype >Object.prototype.__proto__ > null
 		// 对象的链式结构 称为 原型链 可以知道 所有的对象 都有原型 一步步 往上奏 都会汇集到Object.prototype
 		// Object.prototype 是最顶级的在往上找就是null

 		/************/
 		// 词法作用域 不受 块级 作用域的 影响
 		

 		// let num =12;
 		// {
 		// 	//console.log(num);
 		// 	let num =22;
 		// 	 //num =22;
 		// 	console.log(num);
 		// }
 		// console.log(num);

 		// var num=1;
 		// {
 		// 	console.log(num);
 		// 	num=123;
 		// 	console.log(num);
 		// 	var num=111;
 		// 	console.log(num);
 		// }
 		// console.log(num);

 		// 词法作用域： 指变量的访问规则 按照词法定义的规则进行使用
 		// 词法作用域规则 只有函数才可以限定作用域，访问变量从当前作用域开始往上进行查找
 		// 这里的查找 是指 往 作用域的上方进行查找；而不是按照 代码的书写顺序进行查找
 		// 词法作用域的向上查找 是指 从函数内部 向 函数外查找
		// 在JS中 所有的变量作用域 都是 由函数来定义
		// if(0){
		// 	var num=10;
		// }
		// console.log(num);

		// function foo(){
		// 	console.log(num);
		// }
		// var num =123;
		// foo();

		/*作用域 限定规则*/
		// 所有 script 看做全局的作用域 记为 0 级作用域
		// 从上往下， 凡是看到函数 才会出现一个 子集 组用于
			// 		0级作用域
			// function foo(){
			// 	// 子作用域
			// }
			// 0级作用域
			// 变量搜索原则 
			// 首先会在 当前 作用域中查找变量的声明 或定义  如果在当前作用域中找到变量的声明 或定义就使用当前的
			// 如果在当前作用域中没找到 变量的声明 或定义  就去 父级作用域 去查找

		// JS 执行原理  JS 是解释型的语言
		// 就是代码解释一句 执行一句，JS 中代码执行一句出现错误后面的代码就不会执行
		// 为了保证的程序高效的执行 在程序运行一开始的时候 有一个检查过程，如果检查没有问题，
		// 会继续进行下去，将代码 从上到下 从左到右 一句句的 去执行 这个检查的过程就 是 预解析这个执行的过程就叫做 解释执行过程
		// 预解析
		// 1在预解析的时候需要检查基本的语法，语法的错误在预解析的时候就执行
		
		// try{
		// 	var num={;}
		// }catch(e){

		// }
		// console.log(33);

		//2 在当前作用域 中检查 变量名声明， var 就是变量声明的标志。就是在此时运行环境中就已经记录了有什么变量了
		// 检查所有的声明
		// console.log('aaa')
		// console.log(num); // 运行过程中的异常
		// var  num =123; //如果包含var 就表明是个声明 声明 和赋值是分开的，凡是声明的内容在预解析的时候就被运行环境记录下来了
		// // 自然在一开始的时候就不会报错，只是记录下来有这么个名字 用于使用，里面的内容 是什么 不清楚，所以里面的内容是undefined
		// // 如果没有var 就不会讲 num 当做变量 只是简单的检查 是否有语法错误， 变量名提升
		// console.log(num); 

		// 在预解析的时候回记录 函数的声明
		// 3记录函数声明  如果不是函数 声明那么是不会被记录 的

		// foo();
		// function foo(){
		// 	console.log('111');
		// }

		//函数的定义形式 
		// 1声明式  function f(){}  只有这种的声明是才会被 预解析 
		// 函数声明  必须在一个独立的代码当中 不允许 嵌入到语句中  if else
		// 如果在里面 函数声明 会自动 转换为函数表达式 （除外） 不包含
		// foo1();//调用不报错
		// function foo1(){
		// 	// 函数声明 ： 在一个 独立的结构中
		// }

		//foo2(); //此时函数 报错
		// if(1){
		// 	foo2();
		// 	function foo2(){}
		// 	// 函数表达式
		// }

		// width(1){
		// 	foo();
		// 	function foo3(){}
		// 	break;
		// }

		// foo4()
		// {
		// 	foo4();
		// 	function foo4(){}
		// }

		// 讲函数 放在 () 函数就成为 表达式 因此 无法调用 
		// foo5();// 无法调用
		// (function foo5(){

		// });
		// foo5();

		//在（） 中的函数



		// 2函数字面量  var fo = function (){} // 函数表达式 
		// var foo=function a(){
		// 	// 函数表达式的 函数名 只能在函数内部使用
		// }

		// var  foo =function func(){
		// 	//
		// 	console.log(func === foo
		// }

		// foo();
		// if(!'a' in window){
		// 	var a=123;
		// }
		// console.log(a); // undefined 


		// 3使用大写的Function 构造函数

		// var num =123 ;
		// function num(){
		// 	console.log(456);
		// }
		// num();// num is not function

		/**闭包**/
		// 所谓的闭包就是 函数 包括起来的 外面不能访问内部的
		// function a(){
		// 	var num =1;//num在部内声明 属于 局部变量  在1 级作用域中
		// }
		// console.log(num); // num is not defined 

		// 闭包解决的问题： 闭包内的数据外面无法访问
		// 闭包提供了受限制的访问 区域
		// 如果访问闭包中的数据： 就是访问函数中的数据【利用返回值，可以拿到函数中的数据】
		// 利用 return 获得函数中的数据  函数定义的是一个过程
		// function foo(){
		// 	var num =123;
		// 	return num;
		// }

		// var res=foo();
		// console.log(res);

		// function foo(){
		// 	var num =Math.random();
		// 	return num;
		// }
		// var aa =foo();
		// console.log(aa); //打印出的2次结果不一样
		// console.log(aa); // 数据只能返回一次 不能重复使用 


		// function foo1(){
		// 	var num=Math.random();
		// 	function returnF(){
		// 		return num;
		// 	}
		// 	return returnF;
		// }

		// var f = foo1();
		// console.log(f());
		// console.log(f());
		// console.log(f());


		/*闭包的例子*/
		// 1 缓存
		// 闭包允许函数带有一个缓存的结构 只有该函数可以使用的一个独立的内存空间
		// 用法 
		 // var fun = (function(){

		 // 	return function(){

		 // 	} 
		 // })()
		 // 带有缓存的操作 DOM 


		 // var $ = function(select){
		 // 	return document.querySelectorAll(select);
		 // }
		 // var listO =$('div,p');
		 // console.log(listO);
		 // for(var i =0;i<listO.length;i++){
		 // 	listO[i].style.border='1px solid #ccc';
		 // }

		 // 在完成一个页面应用的时候  一般会频繁的 对元素进行获取操作，为了提高效率我们可以将元素缓存


		 // var  $ = (function(){
		 // 	var cache ={};
		 // 	return function(select){
		 // 		// 首先判断缓存中是否 有，如果有就直接使用缓存中的，没有在获取元素
		 // 		var listO;
		 // 		if(cache[select]){
		 // 			//有
		 // 			listO=cache[select];
		 // 		}else{
		 // 			listO = document.querySelectorAll(select);
			//  		cache[select] = listO;
		 // 		}
		 // 		return listO;
		 // 	}
		 // })()

		 // var listO =$('div,p');
		 // for(var i =0;i<listO.length;i++){
		 // 	listO[i].style.border='1px solid #ccc';
		 // }
		 // var list1 =$('div,p');


		//  var $ = (function(){
		//  	var cache ={};
		//  	var cacheKeys =[];
		//  	var len =3;
		//  	return function(select){
		//  		var list;
		//  		if(cache[select]){
		//  			list = cache[select];
		//  		}else{
		//  			// 将维数组 转换成数组
		//  			list =[].slice.call(document.querySelectorAll(select));
		//  			if(cacheKeys.length >=len){
		//  				var key = cacheKeys.shift();
		//  				delete cache[key];
		//  			}
		//  			cacheKeys.push(select);
		//  			cache[select] = list;
		//  		}
		//  		return list;
		//  	}
		//  })()

		//  // 获取div
		// $('div').forEach(v => v.style.border='1px solid red');

		//  //获取p
		// $('p').forEach(v => v.style.border='1px solid green');

		// //获取span
		// $('span').forEach(v => v.style.border='1px solid #2413b3');

		// //获取h6
		// $('h6').forEach(v => v.style.border='1px solid #0bdc85');

		// var num=10;
		// function num(){
		// 	console.log(num);
		// }
		// num();

		// Function.__proto__ =Object 

		// Function = new Function();

	 //    var foo = new Function();

		// function foo(){
		// 	console.log(33);
		// }

		// console.log(foo() ==foo.prototype.constructor())

		// var fun =10;
		// function fun(){
		// 	var  num=10;
		// 	console.log(10);
		// }
		//console.log(num);

		//fun();
		// var i=111;
		// (function(i){
		// 	console.log(i)
		// })(i)

























































































	</script>
</body>
</html>